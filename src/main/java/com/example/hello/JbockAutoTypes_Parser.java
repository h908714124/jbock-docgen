package com.example.hello;

import java.io.File;
import java.io.PrintStream;
import java.lang.Character;
import java.lang.IllegalStateException;
import java.lang.RuntimeException;
import java.lang.String;
import java.lang.StringBuilder;
import java.lang.System;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.StringJoiner;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Generated by <a href="https://github.com/h908714124/jbock">jbock 3.4.011</a>
 */
final class JbockAutoTypes_Parser {
  private PrintStream out = System.out;

  private PrintStream err = System.err;

  private int maxLineWidth = 80;

  private Consumer<ParseResult> runBeforeExit = r -> {};

  private Map<String, String> messages = Collections.emptyMap();

  ParseResult parse(String[] args) {
    if (args.length >= 1 && "--help".equals(args[0]))
      return new HelpRequested();
    try {
      return new ParsingSuccess(parse(Arrays.asList(args).iterator()));
    }
    catch (RuntimeException e) {
      return new ParsingFailed(e);
    }
  }

  JbockAutoTypes_Parser maxLineWidth(int chars) {
    this.maxLineWidth = chars;
    return this;
  }

  JbockAutoTypes_Parser withMessages(Map<String, String> map) {
    this.messages = map;
    return this;
  }

  JbockAutoTypes_Parser withResourceBundle(ResourceBundle bundle) {
    return withMessages(Collections.list(bundle.getKeys()).stream()
      .collect(Collectors.toMap(Function.identity(), bundle::getString)));
  }

  JbockAutoTypes_Parser runBeforeExit(Consumer<ParseResult> runBeforeExit) {
    this.runBeforeExit = runBeforeExit;
    return this;
  }

  JbockAutoTypes_Parser withErrorStream(PrintStream err) {
    this.err = err;
    return this;
  }

  JbockAutoTypes_Parser withHelpStream(PrintStream out) {
    this.out = out;
    return this;
  }

  JbockAutoTypes parseOrExit(String[] args) {
    ParseResult result = parse(args);
    if (result instanceof ParsingSuccess)
      return ((ParsingSuccess) result).getResult();
    if (result instanceof HelpRequested) {
      printOnlineHelp(out);
      out.flush();
      runBeforeExit.accept(result);
      System.exit(0);
    }
    ((ParsingFailed) result).getError().printStackTrace(err);
    err.println("Error: " + ((ParsingFailed) result).getError().getMessage());
    err.println("Try '--help' for more information.");
    err.flush();
    runBeforeExit.accept(result);
    System.exit(1);
    throw new RuntimeException();
  }

  List<Map.Entry<String, String>> buildRows() {
    return Arrays.stream(Option.values()).map(option -> {
      String message = messages.getOrDefault(option.bundleKey, String.join(" ", option.description)).trim();
      return new AbstractMap.SimpleImmutableEntry<String, String>(option.shape, message);
    }).collect(Collectors.toList());
  }

  void printOnlineHelp(PrintStream printStream) {
    printWrap(printStream, 8, "", "Usage: " + synopsis());
    printStream.println();
    for (Map.Entry<String, String> row : buildRows()) {
      String key = String.format("  %1$-26s", row.getKey());
      printWrap(printStream, 28, key, row.getValue());
    }
  }

  void printWrap(PrintStream printStream, int continuationIndent, String init, String input) {
    if (input.isEmpty()) {
      String trim = init.trim();
      printStream.println(init.substring(0, init.indexOf(trim)) + trim);
      return;
    }
    String[] tokens = input.split("\\s+", -1);
    StringBuilder sb = new StringBuilder(init);
    for (String token : tokens) {
      if (token.length() + sb.length() + 1 > maxLineWidth) {
        if (sb.toString().isEmpty()) {
          printStream.println(token);
        }
        else {
          printStream.println(sb);
          sb.setLength(0);
          for (int i = 0; i < continuationIndent; i++)
             sb.append(' ');
          sb.append(token);
        }
      }
      else {
        if (sb.length() > 0 && !Character.isWhitespace(sb.charAt(sb.length() - 1)))
          sb.append(' ');
        sb.append(token);
      }
    }
    if (sb.length() > 0)
      printStream.println(sb);
  }

  String synopsis() {
    return new StringJoiner(" ").add("jbock-auto-types").add(String.format("%s <%s>",
        Option.BIG_DECIMAL.names.get(0),
        Option.BIG_DECIMAL.name().toLowerCase(Locale.US))).add(String.format("%s <%s>",
        Option.BIG_INTEGER.names.get(0),
        Option.BIG_INTEGER.name().toLowerCase(Locale.US))).add(String.format("%s <%s>",
        Option.FILE.names.get(0),
        Option.FILE.name().toLowerCase(Locale.US))).add(String.format("%s <%s>",
        Option.LOCAL_DATE.names.get(0),
        Option.LOCAL_DATE.name().toLowerCase(Locale.US))).add(String.format("%s <%s>",
        Option.PATH.names.get(0),
        Option.PATH.name().toLowerCase(Locale.US))).add(String.format("%s <%s>",
        Option.PATTERN.names.get(0),
        Option.PATTERN.name().toLowerCase(Locale.US))).add(String.format("%s <%s>",
        Option.STRING.names.get(0),
        Option.STRING.name().toLowerCase(Locale.US))).add(String.format("%s <%s>",
        Option.U_RI.names.get(0), Option.U_RI.name().toLowerCase(Locale.US))).toString();
  }

  private JbockAutoTypes parse(Iterator<String> it) {
    int position = 0;
    ParserState state = new ParserState();
    while (it.hasNext()) {
      String token = it.next();
      Option option = state.tryReadOption(token);
      if (option != null) {
        state.optionParsers.get(option).read(option, token, it);
        continue;
      }
      if (!token.isEmpty() && token.charAt(0) == '-')
        throw new RuntimeException("Invalid option: " + token);
      if (position >= state.paramParsers.size())
        throw new RuntimeException("Excess param: " + token);
    }
    return state.build();
  }

  private static String readOptionArgument(String token, Iterator<String> it) {
    if (token.charAt(1) == '-' && token.indexOf('=') >= 0)
      return token.substring(token.indexOf('=') + 1);
    if (token.charAt(1) != '-' && token.length() >= 3)
      return token.substring(2);
    if (!it.hasNext())
      throw new RuntimeException("Missing value after token: " + token);
    return it.next();
  }

  private static class ParserState {
    Map<String, Option> optionNames = Option.optionNames();

    Map<Option, OptionParser> optionParsers = Option.optionParsers();

    List<ParamParser> paramParsers = Option.paramParsers();

    JbockAutoTypes build() {
      return new JbockAutoTypesImpl(
          optionParsers.get(Option.BIG_DECIMAL).values.stream().map(BigDecimal::new).findAny().orElseThrow(Option.BIG_DECIMAL::missingRequired),
          optionParsers.get(Option.BIG_INTEGER).values.stream().map(BigInteger::new).findAny().orElseThrow(Option.BIG_INTEGER::missingRequired),
          optionParsers.get(Option.FILE).values.stream().map(s -> {
            File f = new File(s);
            if (!f.exists()) {
              throw new IllegalStateException("File does not exist: " + s);
            }
            if (!f.isFile()) {
              throw new IllegalStateException("Not a file: " + s);
            }
            return f;
          }).findAny().orElseThrow(Option.FILE::missingRequired),
          optionParsers.get(Option.LOCAL_DATE).values.stream().map(LocalDate::parse).findAny().orElseThrow(Option.LOCAL_DATE::missingRequired),
          optionParsers.get(Option.PATH).values.stream().map(Paths::get).findAny().orElseThrow(Option.PATH::missingRequired),
          optionParsers.get(Option.PATTERN).values.stream().map(Pattern::compile).findAny().orElseThrow(Option.PATTERN::missingRequired),
          optionParsers.get(Option.STRING).values.stream().map(Function.identity()).findAny().orElseThrow(Option.STRING::missingRequired),
          optionParsers.get(Option.U_RI).values.stream().map(URI::create).findAny().orElseThrow(Option.U_RI::missingRequired));
    }

    Option tryReadOption(String token) {
      if (token.length() <= 1 || token.charAt(0) != '-')
        return null;
      if (token.charAt(1) != '-')
        return optionNames.get(token.substring(0, 2));
      int index = token.indexOf('=');
      return optionNames.get(token.substring(0, index < 0 ? token.length() : index));
    }
  }

  private static class JbockAutoTypesImpl extends JbockAutoTypes {
    BigDecimal bigDecimal;

    BigInteger bigInteger;

    File file;

    LocalDate localDate;

    Path path;

    Pattern pattern;

    String string;

    URI uRi;

    JbockAutoTypesImpl(BigDecimal bigDecimal, BigInteger bigInteger, File file, LocalDate localDate,
        Path path, Pattern pattern, String string, URI uRi) {
      this.bigDecimal = bigDecimal;
      this.bigInteger = bigInteger;
      this.file = file;
      this.localDate = localDate;
      this.path = path;
      this.pattern = pattern;
      this.string = string;
      this.uRi = uRi;
    }

    BigDecimal bigDecimal() {
      return bigDecimal;
    }

    BigInteger bigInteger() {
      return bigInteger;
    }

    File file() {
      return file;
    }

    LocalDate localDate() {
      return localDate;
    }

    Path path() {
      return path;
    }

    Pattern pattern() {
      return pattern;
    }

    String string() {
      return string;
    }

    URI uRI() {
      return uRi;
    }
  }

  private enum Option {
    BIG_DECIMAL(Collections.singletonList("--BigDecimal"), "BigDecimal", Collections.singletonList("Mapped by: java.math.BigDecimal::new"), "--BigDecimal BIG_DECIMAL"),

    BIG_INTEGER(Collections.singletonList("--BigInteger"), "BigInteger", Collections.singletonList("Mapped by: java.math.BigInteger::new"), "--BigInteger BIG_INTEGER"),

    FILE(Collections.singletonList("--File"), "File", Arrays.asList("Mapped by: <pre>{@code s -> {",
        "java.io.File f = new java.io.File(s);", "if (!f.exists()) {",
        "throw new java.lang.IllegalStateException(\"File does not exist: \" + s);", "}",
        "if (!f.isFile()) {", "throw new java.lang.IllegalStateException(\"Not a file: \" + s);",
        "}", "return f;", "}}</pre>"), "--File FILE"),

    LOCAL_DATE(Collections.singletonList("--LocalDate"), "LocalDate", Collections.singletonList("Mapped by: java.time.LocalDate::parse"), "--LocalDate LOCAL_DATE"),

    PATH(Collections.singletonList("--Path"), "Path", Collections.singletonList("Mapped by: java.nio.file.Paths::get"), "--Path PATH"),

    PATTERN(Collections.singletonList("--Pattern"), "Pattern", Collections.singletonList("Mapped by: java.util.regex.Pattern::compile"), "--Pattern PATTERN"),

    STRING(Collections.singletonList("--String"), "String", Collections.singletonList("Mapped by: java.util.function.Function.identity()"), "--String STRING"),

    U_RI(Collections.singletonList("--URI"), "URI", Collections.singletonList("Mapped by: java.net.URI::create"), "--URI U_RI");

    List<String> names;

    String bundleKey;

    List<String> description;

    String shape;

    Option(List<String> names, String bundleKey, List<String> description, String shape) {
      this.names = names;
      this.bundleKey = bundleKey;
      this.description = description;
      this.shape = shape;
    }

    RuntimeException missingRequired() {
      return new RuntimeException("Missing required: " + name() +
        (names.isEmpty() ? "" : " (" + String.join(", ", names) + ")"));
    }

    static Map<String, Option> optionNames() {
      Map<String, Option> result = new HashMap<>(Option.values().length);
      for (Option option : Option.values())
        option.names.forEach(name -> result.put(name, option));
      return result;
    }

    static Map<Option, OptionParser> optionParsers() {
      Map<Option, OptionParser> parsers = new EnumMap<>(Option.class);
      parsers.put(BIG_DECIMAL, new RegularOptionParser());
      parsers.put(BIG_INTEGER, new RegularOptionParser());
      parsers.put(FILE, new RegularOptionParser());
      parsers.put(LOCAL_DATE, new RegularOptionParser());
      parsers.put(PATH, new RegularOptionParser());
      parsers.put(PATTERN, new RegularOptionParser());
      parsers.put(STRING, new RegularOptionParser());
      parsers.put(U_RI, new RegularOptionParser());
      return parsers;
    }

    static List<ParamParser> paramParsers() {
      return Collections.emptyList();
    }
  }

  private static class OptionParser {
    List<String> values = new ArrayList<>();

    void read(Option option, String token, Iterator<String> it) {
      values.add(readOptionArgument(token, it));
    }
  }

  private static class FlagParser extends OptionParser {
    void read(Option option, String token, Iterator<String> it) {
      if (token.charAt(1) != '-' && token.length() > 2 || token.contains("="))
        throw new RuntimeException("Invalid token: " + token);
      if (!values.isEmpty())
        throw new RuntimeException(String.format("Option %s (%s) is not repeatable", option,
            String.join(", ", option.names)));
      values.add("");
    }
  }

  private static class RegularOptionParser extends OptionParser {
    void read(Option option, String token, Iterator<String> it) {
      if (!values.isEmpty())
        throw new RuntimeException(String.format("Option %s (%s) is not repeatable", option,
            String.join(", ", option.names)));
      super.read(option, token, it);
    }
  }

  private static class ParamParser {
    List<String> values = new ArrayList<>();

    int read(String value) {
      values.add(value);
      return 0;
    }
  }

  abstract static class ParseResult {
    private ParseResult() {
    }
  }

  static final class ParsingFailed extends ParseResult {
    private final RuntimeException error;

    private ParsingFailed(RuntimeException error) {
      this.error = error;
    }

    RuntimeException getError() {
      return error;
    }
  }

  static final class ParsingSuccess extends ParseResult {
    private final JbockAutoTypes result;

    private ParsingSuccess(JbockAutoTypes result) {
      this.result = result;
    }

    JbockAutoTypes getResult() {
      return result;
    }
  }

  static final class HelpRequested extends ParseResult {
  }
}

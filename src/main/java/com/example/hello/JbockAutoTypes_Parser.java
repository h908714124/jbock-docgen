package com.example.hello;

import java.io.File;
import java.io.PrintStream;
import java.lang.AssertionError;
import java.lang.Character;
import java.lang.IllegalArgumentException;
import java.lang.IllegalStateException;
import java.lang.Override;
import java.lang.RuntimeException;
import java.lang.String;
import java.lang.StringBuilder;
import java.lang.System;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.OptionalInt;
import java.util.ResourceBundle;
import java.util.StringJoiner;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import java.util.stream.Stream;

/**
 * Generated by
 * <a href="https://github.com/h908714124/jbock">jbock 3.4</a>
 */
final class JbockAutoTypes_Parser {
  private PrintStream out = System.out;

  private PrintStream err = System.err;

  private int maxLineWidth = 80;

  private Consumer<ParseResult> runBeforeExit = r -> {};

  private Map<String, String> messages;

  private JbockAutoTypes_Parser() {
  }

  static JbockAutoTypes_Parser create() {
    return new JbockAutoTypes_Parser();
  }

  ParseResult parse(String[] args) {
    Messages msg = new Messages(messages == null ? Collections.emptyMap() : messages);
    return new Tokenizer(msg).parse(args);
  }

  JbockAutoTypes parseOrExit(String[] args) {
    ParseResult result = parse(args);
    if (result instanceof ParsingSuccess) {
      return ((ParsingSuccess) result).getResult();
    }
    if (result instanceof HelpRequested) {
      HelpRequested helpResult = (HelpRequested) result;
      printOnlineHelp(out, helpResult.getSynopsis(), helpResult.getRows());
      runBeforeExit.accept(result);
      System.exit(0);
    }
    if (result instanceof ParsingFailed) {
      ParsingFailed errorResult = (ParsingFailed) result;
      errorResult.getError().printStackTrace(err);
      err.println("Error: " + errorResult.getError().getMessage());
      printOnlineHelp(err, errorResult.getSynopsis(), errorResult.getRows());
      err.println("Try '--help' for more information.");
      runBeforeExit.accept(result);
      System.exit(1);
    }
    throw new AssertionError("all cases handled");
  }

  private void printOnlineHelp(PrintStream printStream, String synopsis,
      List<Map.Entry<String, String>> rows) {
    int keyWidth = rows.stream().map(Map.Entry::getKey).mapToInt(String::length).max().orElse(0) + 2;
    String keyFormat = "%1$-" + keyWidth + "s";
    printWrap(printStream, 8, "", "Usage: " + synopsis);
    for (Map.Entry<String, String> row : rows) {
      String key = String.format(keyFormat, row.getKey());
      printWrap(printStream, keyWidth, key, row.getValue());
    }
    printStream.flush();
  }

  private void printWrap(PrintStream printStream, int continuationIndent, String init,
      String input) {
    if (input.isEmpty()) {
      String trim = init.trim();
      printStream.println(init.substring(0, init.indexOf(trim)) + trim);
      return;
    }
    String[] tokens = input.split("\\s+", -1);
    StringBuilder row = new StringBuilder(init);
    for (String token : tokens) {
      if (token.length() + row.length() + 1 > maxLineWidth) {
        if (row.toString().isEmpty()) {
          printStream.println(token);
        }
        else {
          printStream.println(row);
          row.setLength(0);
          for (int i = 0; i < continuationIndent; i++) {
            row.append(' ');
          }
          row.append(token);
        }
      }
      else {
        if (row.length() > 0 && !Character.isWhitespace(row.charAt(row.length() - 1))) {
          row.append(' ');
        }
        row.append(token);
      }
    }
    if (row.length() > 0) {
      printStream.println(row);
    }
  }

  JbockAutoTypes_Parser withErrorStream(PrintStream err) {
    this.err = Objects.requireNonNull(err);
    return this;
  }

  JbockAutoTypes_Parser maxLineWidth(int chars) {
    this.maxLineWidth = chars;
    return this;
  }

  JbockAutoTypes_Parser withMessages(Map<String, String> map) {
    this.messages = Objects.requireNonNull(map);
    return this;
  }

  JbockAutoTypes_Parser withResourceBundle(ResourceBundle bundle) {
    Map<String, String> map = new HashMap<>();
    for (String name : Collections.list(bundle.getKeys())) {
      map.put(name, bundle.getString(name));
    }
    return withMessages(map);
  }

  JbockAutoTypes_Parser runBeforeExit(Consumer<ParseResult> runBeforeExit) {
    this.runBeforeExit = runBeforeExit;
    return this;
  }

  private static String readValidArgument(String token, Iterator<String> it) {
    boolean isLong = token.charAt(1) == '-';
    int index = token.indexOf('=');
    if (isLong && index >= 0) {
      return token.substring(index + 1);
    }
    if (!isLong && token.length() >= 3) {
      return token.substring(2);
    }
    if (!it.hasNext()) {
      throw new IllegalArgumentException("Missing value after token: " + token);
    }
    return it.next();
  }

  JbockAutoTypes_Parser withOutputStream(PrintStream out) {
    this.out = Objects.requireNonNull(out);
    return this;
  }

  private static class Tokenizer {
    final Messages messages;

    Tokenizer(Messages messages) {
      this.messages = messages;
    }

    ParseResult parse(String[] args) {
      if (args.length >= 1 && "--help".equals(args[0])) {
        return new HelpRequested(synopsis(), buildRows());
      }
      try {
        return new ParsingSuccess(parse(Arrays.asList(args).iterator()));
      }
      catch (RuntimeException e) {
        return new ParsingFailed(synopsis(), buildRows(), e);
      }
    }

    JbockAutoTypes parse(Iterator<String> it) {
      int position = 0;
      ParserState state = new ParserState();
      while (it.hasNext()) {
        String token = it.next();
        Option option = state.tryReadOption(token);
        if (option != null) {
          state.parsers.get(option).read(token, it);
          continue;
        }
        if (!token.isEmpty() && token.charAt(0) == '-') {
          throw new IllegalArgumentException("Invalid option: " + token);
        }
        if (position >= state.positionalParsers.size()) {
          throw new IllegalArgumentException("Invalid option: " + token);
        }
        position += state.positionalParsers.get(position).read(token);
      }
      return state.build();
    }

    static String synopsis() {
      StringJoiner joiner = new StringJoiner(" ");
      joiner.add("jbock-auto-types");
      joiner.add(String.format("%s <%s>", Option.BIG_DECIMAL.names.get(0), Option.BIG_DECIMAL.name().toLowerCase(Locale.US)));
      joiner.add(String.format("%s <%s>", Option.BIG_INTEGER.names.get(0), Option.BIG_INTEGER.name().toLowerCase(Locale.US)));
      joiner.add(String.format("%s <%s>", Option.FILE.names.get(0), Option.FILE.name().toLowerCase(Locale.US)));
      joiner.add(String.format("%s <%s>", Option.LOCAL_DATE.names.get(0), Option.LOCAL_DATE.name().toLowerCase(Locale.US)));
      joiner.add(String.format("%s <%s>", Option.PATH.names.get(0), Option.PATH.name().toLowerCase(Locale.US)));
      joiner.add(String.format("%s <%s>", Option.PATTERN.names.get(0), Option.PATTERN.name().toLowerCase(Locale.US)));
      joiner.add(String.format("%s <%s>", Option.STRING.names.get(0), Option.STRING.name().toLowerCase(Locale.US)));
      joiner.add(String.format("%s <%s>", Option.U_RI.names.get(0), Option.U_RI.name().toLowerCase(Locale.US)));
      return joiner.toString();
    }

    List<Map.Entry<String, String>> buildRows() {
      List<Map.Entry<String, String>> rows = new ArrayList<>();
      for (Option option: Option.values()) {
        rows.add(printDescription(option));
      }
      return rows;
    }

    Map.Entry<String, String> printDescription(Option option) {
      String message = messages.getMessage(option.bundleKey, option.description);
      String description;
      if (option.positionalIndex.isPresent()) {
        description = option.name().toLowerCase(Locale.US);
      }
      else if (option.flag) {
        description = option.describeParam("");
      }
      else {
        description = option.describeParam(' ' + option.name());
      }
      return new AbstractMap.SimpleImmutableEntry<String, String>(description, message);
    }
  }

  private static class ParserState {
    final Map<String, Option> optionNames = Collections.unmodifiableMap(Option.optionNames());

    final Map<Option, OptionParser> parsers = Collections.unmodifiableMap(Option.parsers());

    final List<PositionalOptionParser> positionalParsers = Collections.unmodifiableList(Option.positionalParsers());

    JbockAutoTypes build() {
      return new JbockAutoTypesImpl(
          parsers.get(Option.BIG_DECIMAL).values().map(BigDecimal::new).findAny().orElseThrow(Option.BIG_DECIMAL.missingRequired()),
          parsers.get(Option.BIG_INTEGER).values().map(BigInteger::new).findAny().orElseThrow(Option.BIG_INTEGER.missingRequired()),
          parsers.get(Option.FILE).values().map(s -> {
            File f = new File(s);
            if (!f.exists()) {
              throw new IllegalStateException("File does not exist: " + s);
            }
            if (!f.isFile()) {
              throw new IllegalStateException("Not a file: " + s);
            }
            return f;
          }).findAny().orElseThrow(Option.FILE.missingRequired()),
          parsers.get(Option.LOCAL_DATE).values().map(LocalDate::parse).findAny().orElseThrow(Option.LOCAL_DATE.missingRequired()),
          parsers.get(Option.PATH).values().map(Paths::get).findAny().orElseThrow(Option.PATH.missingRequired()),
          parsers.get(Option.PATTERN).values().map(Pattern::compile).findAny().orElseThrow(Option.PATTERN.missingRequired()),
          parsers.get(Option.STRING).values().map(Function.identity()).findAny().orElseThrow(Option.STRING.missingRequired()),
          parsers.get(Option.U_RI).values().map(URI::create).findAny().orElseThrow(Option.U_RI.missingRequired()));
    }

    Option tryReadOption(String token) {
      if (token.length() <= 1 || token.charAt(0) != '-') {
        return null;
      }
      if (token.charAt(1) == '-') {
        int index = token.indexOf('=');
        return optionNames.get(token.substring(0, index < 0 ? token.length() : index));
      }
      return optionNames.get(token.substring(0, 2));
    }
  }

  private static class JbockAutoTypesImpl extends JbockAutoTypes {
    final BigDecimal bigDecimal;

    final BigInteger bigInteger;

    final File file;

    final LocalDate localDate;

    final Path path;

    final Pattern pattern;

    final String string;

    final URI uRi;

    JbockAutoTypesImpl(BigDecimal bigDecimal, BigInteger bigInteger, File file, LocalDate localDate,
        Path path, Pattern pattern, String string, URI uRi) {
      this.bigDecimal = bigDecimal;
      this.bigInteger = bigInteger;
      this.file = file;
      this.localDate = localDate;
      this.path = path;
      this.pattern = pattern;
      this.string = string;
      this.uRi = uRi;
    }

    @Override
    BigDecimal bigDecimal() {
      return bigDecimal;
    }

    @Override
    BigInteger bigInteger() {
      return bigInteger;
    }

    @Override
    File file() {
      return file;
    }

    @Override
    LocalDate localDate() {
      return localDate;
    }

    @Override
    Path path() {
      return path;
    }

    @Override
    Pattern pattern() {
      return pattern;
    }

    @Override
    String string() {
      return string;
    }

    @Override
    URI uRI() {
      return uRi;
    }
  }

  private enum Option {
    BIG_DECIMAL(Collections.singletonList("--BigDecimal"), "BigDecimal", false, OptionalInt.empty(), Collections.singletonList("Mapped by: java.math.BigDecimal::new")),

    BIG_INTEGER(Collections.singletonList("--BigInteger"), "BigInteger", false, OptionalInt.empty(), Collections.singletonList("Mapped by: java.math.BigInteger::new")),

    FILE(Collections.singletonList("--File"), "File", false, OptionalInt.empty(), Arrays.asList(
        "Mapped by: <pre>{@code s -> {","java.io.File f = new java.io.File(s);",
        "if (!f.exists()) {",
        "throw new java.lang.IllegalStateException(\"File does not exist: \" + s);","}",
        "if (!f.isFile()) {","throw new java.lang.IllegalStateException(\"Not a file: \" + s);","}",
        "return f;","}}</pre>")),

    LOCAL_DATE(Collections.singletonList("--LocalDate"), "LocalDate", false, OptionalInt.empty(), Collections.singletonList("Mapped by: java.time.LocalDate::parse")),

    PATH(Collections.singletonList("--Path"), "Path", false, OptionalInt.empty(), Collections.singletonList("Mapped by: java.nio.file.Paths::get")),

    PATTERN(Collections.singletonList("--Pattern"), "Pattern", false, OptionalInt.empty(), Collections.singletonList("Mapped by: java.util.regex.Pattern::compile")),

    STRING(Collections.singletonList("--String"), "String", false, OptionalInt.empty(), Collections.singletonList("Mapped by: java.util.function.Function.identity()")),

    U_RI(Collections.singletonList("--URI"), "URI", false, OptionalInt.empty(), Collections.singletonList("Mapped by: java.net.URI::create"));

    final List<String> names;

    final boolean flag;

    final String bundleKey;

    final OptionalInt positionalIndex;

    final List<String> description;

    Option(List<String> names, String bundleKey, boolean flag, OptionalInt positionalIndex,
        List<String> description) {
      this.names = names;
      this.flag = flag;
      this.bundleKey = bundleKey;
      this.positionalIndex = positionalIndex;
      this.description = description;
    }

    String describeParam(String argname) {
      if (names.size() == 1) {
        return "    " + names.get(0) + argname;
      }
      return names.get(0) + ", " + names.get(1) + argname;
    }

    Supplier<IllegalArgumentException> missingRequired() {
      return () -> positionalIndex.isPresent()
        ? new IllegalArgumentException(String.format("Missing parameter: <%s>", this))
        : new IllegalArgumentException(String.format("Missing required option: %s (%s)", this, describeParam("").trim()));
    }

    static Map<String, Option> optionNames() {
      Map<String, Option> result = new HashMap<>(Option.values().length);
      for (Option option : Option.values()) {
        for (String name : option.names) {
          result.put(name, option);
        }
      }
      return result;
    }

    static Map<Option, OptionParser> parsers() {
      Map<Option, OptionParser> parsers = new EnumMap<>(Option.class);
      parsers.put(BIG_DECIMAL, new RegularOptionParser(BIG_DECIMAL));
      parsers.put(BIG_INTEGER, new RegularOptionParser(BIG_INTEGER));
      parsers.put(FILE, new RegularOptionParser(FILE));
      parsers.put(LOCAL_DATE, new RegularOptionParser(LOCAL_DATE));
      parsers.put(PATH, new RegularOptionParser(PATH));
      parsers.put(PATTERN, new RegularOptionParser(PATTERN));
      parsers.put(STRING, new RegularOptionParser(STRING));
      parsers.put(U_RI, new RegularOptionParser(U_RI));
      return parsers;
    }

    static List<PositionalOptionParser> positionalParsers() {
      List<PositionalOptionParser> parsers = new ArrayList<>();
      return parsers;
    }
  }

  private abstract static class OptionParser {
    final Option option;

    OptionParser(Option option) {
      this.option = option;
    }

    abstract void read(String token, Iterator<String> it);

    Stream<String> values() {
      throw new AssertionError();
    }
  }

  private static class FlagOptionParser extends OptionParser {
    boolean flag;

    FlagOptionParser(Option option) {
      super(option);
    }

    @Override
    void read(String token, Iterator<String> it) {
      if (token.charAt(1) != '-' && token.length() > 2 || token.contains("=")) {
        throw new IllegalArgumentException("Invalid token: " + token);
      }
      if (flag) {
        throw new IllegalArgumentException(String.format("Option %s (%s) is not repeatable", option, option.describeParam("").trim()));
      }
      flag = true;
    }

    @Override
    Stream<String> values() {
      return flag ? Stream.of("") : Stream.empty();
    }
  }

  private static class RegularOptionParser extends OptionParser {
    String value;

    RegularOptionParser(Option option) {
      super(option);
    }

    @Override
    void read(String token, Iterator<String> it) {
      if (value != null) {
        throw new IllegalArgumentException(String.format("Option %s (%s) is not repeatable", option, option.describeParam("").trim()));
      }
      value = readValidArgument(token, it);
    }

    @Override
    Stream<String> values() {
      return value == null ? Stream.empty() : Stream.of(value);
    }
  }

  private static class RepeatableOptionParser extends OptionParser {
    List<String> values = new ArrayList<>();

    RepeatableOptionParser(Option option) {
      super(option);
    }

    @Override
    void read(String token, Iterator<String> it) {
      values.add(readValidArgument(token, it));
    }

    @Override
    Stream<String> values() {
      return values.stream();
    }
  }

  private abstract static class PositionalOptionParser {
    abstract int read(String token);

    Stream<String> values() {
      throw new AssertionError();
    }
  }

  private static class RegularPositionalOptionParser extends PositionalOptionParser {
    String value;

    @Override
    int read(String value) {
      this.value = value;
      return 1;
    }

    @Override
    Stream<String> values() {
      return value == null ? Stream.empty() : Stream.of(value);
    }
  }

  private static class RepeatablePositionalOptionParser extends PositionalOptionParser {
    List<String> values = new ArrayList<>();

    @Override
    int read(String value) {
      values.add(value);
      return 0;
    }

    @Override
    Stream<String> values() {
      return values.stream();
    }
  }

  private static class Messages {
    final Map<String, String> messages;

    Messages(Map<String, String> messages) {
      this.messages = messages;
    }

    String getMessage(String key, List<String> defaultValue) {
      return messages.getOrDefault(key, String.join(" ", defaultValue)).trim();
    }
  }

  abstract static class ParseResult {
    private ParseResult() {
    }
  }

  static final class ParsingFailed extends ParseResult {
    private final String synopsis;

    private final List<Map.Entry<String, String>> rows;

    private final RuntimeException error;

    private ParsingFailed(String synopsis, List<Map.Entry<String, String>> rows,
        RuntimeException error) {
      this.error = error;
      this.synopsis = synopsis;
      this.rows = rows;
    }

    String getSynopsis() {
      return synopsis;
    }

    List<Map.Entry<String, String>> getRows() {
      return rows;
    }

    RuntimeException getError() {
      return error;
    }
  }

  static final class ParsingSuccess extends ParseResult {
    private final JbockAutoTypes result;

    private ParsingSuccess(JbockAutoTypes result) {
      this.result = result;
    }

    JbockAutoTypes getResult() {
      return result;
    }
  }

  static final class HelpRequested extends ParseResult {
    private final String synopsis;

    private final List<Map.Entry<String, String>> rows;

    private HelpRequested(String synopsis, List<Map.Entry<String, String>> rows) {
      this.synopsis = synopsis;
      this.rows = rows;
    }

    String getSynopsis() {
      return synopsis;
    }

    List<Map.Entry<String, String>> getRows() {
      return rows;
    }
  }
}
